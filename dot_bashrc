# Quinlan Git Bash profile (Windows native)
export CLAUDE_CODE_GIT_BASH_PATH='C:\Program Files\Git\bin\bash.exe'

if [[ "$PATH" == *";"* ]] && [[ -x /usr/bin/cygpath ]]; then
    PATH="$(/usr/bin/cygpath -u -p "$PATH")"
fi

if [ -d /usr/bin ]; then
    case ":$PATH:" in
        *":/usr/bin:"*) ;;
        *) export PATH="/usr/bin:$PATH" ;;
    esac
fi

if [ -d /mingw64/bin ]; then
    case ":$PATH:" in
        *":/mingw64/bin:"*) ;;
        *) export PATH="/mingw64/bin:$PATH" ;;
    esac
fi

_win_path() {
    local value="$1"
    if command -v cygpath >/dev/null 2>&1; then
        cygpath -u "$value"
        return
    fi
    if [ -x /usr/bin/cygpath ]; then
        /usr/bin/cygpath -u "$value"
        return
    fi
    printf '%s' "${value//\\//}"
}

if [ -n "$LOCALAPPDATA" ]; then
    win_links="$(_win_path "$LOCALAPPDATA")/Microsoft/WinGet/Links"
    if [ -d "$win_links" ]; then
        export PATH="$win_links:$PATH"
    fi
fi

if [ -d "$HOME/.local/bin" ]; then
    case ":$PATH:" in
        *":$HOME/.local/bin:"*) ;;
        *) export PATH="$HOME/.local/bin:$PATH" ;;
    esac
fi

if [ -n "$APPDATA" ]; then
    npm_bin="$(_win_path "$APPDATA")/npm"
    if [ -d "$npm_bin" ]; then
        case ":$PATH:" in
            *":$npm_bin:"*) ;;
            *) export PATH="$npm_bin:$PATH" ;;
        esac
    fi
fi

if [ -n "$LOCALAPPDATA" ]; then
    uv_bin="$(_win_path "$LOCALAPPDATA")/uv/bin"
    if [ -d "$uv_bin" ]; then
        case ":$PATH:" in
            *":$uv_bin:"*) ;;
            *) export PATH="$uv_bin:$PATH" ;;
        esac
    fi
fi

if command -v mise >/dev/null 2>&1; then
    if [ -n "$LOCALAPPDATA" ]; then
        mise_shims="$(_win_path "$LOCALAPPDATA")/mise/shims"
        if [ -d "$mise_shims" ]; then
            case ":$PATH:" in
                *":$mise_shims:"*) ;;
                *) export PATH="$mise_shims:$PATH" ;;
            esac
        fi
    fi
fi

unset -f _win_path

# Auto-source project env when entering a repo with scripts/dev/env.sh
# This runs on every prompt but only sources if we've changed directories into a new project.
_quinlan_auto_env() {
    local dir="$PWD"
    # Walk up to find repo root (look for scripts/dev/env.sh marker)
    while [[ "$dir" != "/" ]]; do
        if [[ -f "$dir/scripts/dev/env.sh" ]]; then
            # Only source if we haven't already for this repo root
            if [[ "$_QUINLAN_ENV_ROOT" != "$dir" ]]; then
                # shellcheck source=/dev/null
                source "$dir/scripts/dev/env.sh"
            fi
            return
        fi
        dir="$(dirname "$dir")"
    done
}
PROMPT_COMMAND="_quinlan_auto_env${PROMPT_COMMAND:+;$PROMPT_COMMAND}"

# ---------------------------------------------------------------------------
# Agent commands
# ---------------------------------------------------------------------------

# Claude Code (Windows native, Git Bash) - works for everyone
# Sets CLAUDE_CODE_TASK_LIST_ID based on worktree name so all Claude instances
# in the same worktree share a task list.
cc() {
    local task_id=""
    local dir
    dir=$(basename "$PWD")

    # Determine task list ID based on project context
    if [[ "$dir" == quinlan* ]]; then
        task_id="$dir"
    elif git rev-parse --is-inside-work-tree &>/dev/null; then
        task_id=$(basename "$(git rev-parse --show-toplevel)")
    fi

    # Run in subshell to avoid leaking env var; single claude invocation (DRY)
    (
        [[ -n "$task_id" ]] && export CLAUDE_CODE_TASK_LIST_ID="$task_id"
        claude --dangerously-skip-permissions "$@"
    )
}

# ---------------------------------------------------------------------------
# WSL integration (Timon's Codex workflow - only loads if WSL available)
# ---------------------------------------------------------------------------

if command -v wsl.exe &>/dev/null; then

# Detect WSL username once (works across machines)
WSL_USER=$(wsl.exe -d Ubuntu -e whoami 2>/dev/null | tr -d '\r')
WSL_PROJECTS="/home/${WSL_USER}/projects"

# Helper: ensure Windows worktree exists for a branch
_ensure_win_worktree() {
    local branch="$1"
    local workspace="${WORKSPACE_ROOT:-/e/projects/main_workspace}"
    local main_repo="$workspace/quinlan"
    local suffix="${branch##*/}"
    local win_dir="quinlan-$suffix"
    local win_path="$workspace/$win_dir"

    if [[ ! -d "$main_repo/.git" && ! -f "$main_repo/.git" ]]; then
        echo "Error: main repo not found at $main_repo" >&2
        return 1
    fi

    # Ensure branch exists locally (create from origin/main if missing)
    if ! git -C "$main_repo" rev-parse --verify "$branch" &>/dev/null; then
        if git -C "$main_repo" ls-remote --exit-code --heads origin "$branch" &>/dev/null; then
            git -C "$main_repo" fetch origin "$branch" &>/dev/null || true
            git -C "$main_repo" branch "$branch" "origin/$branch" >&2
        else
            echo "Creating branch $branch from main..." >&2
            git -C "$main_repo" fetch origin main &>/dev/null || true
            if git -C "$main_repo" rev-parse --verify origin/main &>/dev/null; then
                git -C "$main_repo" branch "$branch" "origin/main" >&2
            else
                git -C "$main_repo" branch "$branch" "main" >&2
            fi
        fi
    fi

    # Create worktree if missing
    if [[ ! -d "$win_path/.git" && ! -f "$win_path/.git" ]]; then
        echo "Creating Windows worktree: $win_path (branch: $branch)" >&2
        git -C "$main_repo" worktree add "$win_path" "$branch" >&2 || {
            echo "Error: Failed to create Windows worktree." >&2
            return 1
        }
    fi

    git -C "$win_path" config core.autocrlf input
    printf '%s' "$win_path"
}

# Helper: ensure WSL worktree exists and is on the right branch
# Only syncs if branch differs or worktree doesn't exist
_ensure_wsl_worktree() {
    local win_dir="$1"
    local branch="${2:-}"
    local main_repo="${3:-}"
    local wsl_base="$WSL_PROJECTS"
    local wsl_path="$wsl_base/$win_dir"
    local wsl_main="$wsl_base/quinlan"

    if [[ -z "$branch" ]]; then
        branch=$(git branch --show-current)
    fi
    if [[ -z "$main_repo" ]]; then
        main_repo=$(git rev-parse --show-toplevel 2>/dev/null)
    fi
    if [[ -z "$branch" ]]; then
        echo "Error: Unable to determine branch for WSL worktree."
        return 1
    fi

    # Ensure branch exists on origin (required for WSL to access it)
    if ! git -C "$main_repo" ls-remote --exit-code --heads origin "$branch" &>/dev/null; then
        echo "Pushing $branch to origin for WSL sync..."
        git -C "$main_repo" push -u origin "$branch" || { echo "Failed to push branch"; return 1; }
    fi

    # Determine worktree state using git (more reliable than filesystem checks)
    # States: registered (exists), stale (registered but missing), orphan (dir exists but not registered), missing
    local wt_registered wt_dir_exists wt_state
    wt_registered=$(wsl -d Ubuntu -e bash -c "cd '$wsl_main' && git worktree list --porcelain 2>/dev/null | grep -q '^worktree $wsl_path\$' && echo yes || echo no")
    wt_dir_exists=$(wsl -d Ubuntu -e bash -c "[ -d '$wsl_path' ] && echo yes || echo no")

    if [[ "$wt_registered" == "yes" && "$wt_dir_exists" == "yes" ]]; then
        wt_state="registered"
    elif [[ "$wt_registered" == "yes" && "$wt_dir_exists" == "no" ]]; then
        wt_state="stale"
    elif [[ "$wt_registered" == "no" && "$wt_dir_exists" == "yes" ]]; then
        wt_state="orphan"
    elif [[ "$wt_registered" == "no" && "$wt_dir_exists" == "no" ]]; then
        wt_state="missing"
    else
        echo "Error: Could not determine WSL worktree state (registered=$wt_registered, exists=$wt_dir_exists)"
        echo "Check WSL is running: wsl -d Ubuntu -e bash -c 'cd $wsl_main && git worktree list'"
        return 1
    fi

    case "$wt_state" in
        registered)
            # Worktree exists - ensure correct branch (handles detached HEAD)
            local wsl_branch
            wsl_branch=$(wsl -d Ubuntu -e bash -c "cd '$wsl_path' && git branch --show-current 2>/dev/null")
            if [[ -z "$wsl_branch" ]]; then
                echo "Fixing detached HEAD: $wsl_path → $branch"
                wsl -d Ubuntu -e bash -c "cd '$wsl_path' && git fetch origin && git checkout '$branch' && git pull --ff-only 2>/dev/null || true"
            elif [[ "$wsl_branch" != "$branch" ]]; then
                echo "Switching WSL worktree: $wsl_path → $branch"
                wsl -d Ubuntu -e bash -c "cd '$wsl_path' && git fetch origin && git checkout '$branch' && git pull --ff-only 2>/dev/null || true"
            fi
            ;;
        stale)
            echo "Pruning stale worktree: $wsl_path"
            wsl -d Ubuntu -e bash -c "cd '$wsl_main' && git worktree prune"
            _create_wsl_worktree "$wsl_path" "$branch" "$wsl_main" || return 1
            ;;
        orphan)
            echo "Removing orphan directory: $wsl_path"
            wsl -d Ubuntu -e bash -c "rm -rf '$wsl_path'"
            _create_wsl_worktree "$wsl_path" "$branch" "$wsl_main" || return 1
            ;;
        missing)
            _create_wsl_worktree "$wsl_path" "$branch" "$wsl_main" || return 1
            ;;
    esac

    # Ensure correct git config
    wsl -d Ubuntu -e bash -c "cd '$wsl_path' && git config core.autocrlf input" 2>/dev/null || true

    # Generate AGENTS.md for Codex (concatenate main + local context)
    wsl -d Ubuntu -e bash -c "
        [ -L '$wsl_path/AGENTS.md' ] && rm -f '$wsl_path/AGENTS.md'
        cat '$wsl_path/CLAUDE.md' '$wsl_path/workspaces/timon/CLAUDE.local.template.md' > '$wsl_path/.AGENTS.md.tmp' 2>/dev/null && mv '$wsl_path/.AGENTS.md.tmp' '$wsl_path/AGENTS.md'
        [ -f '$wsl_path/AGENTS.md' ] && git -C '$wsl_path' update-index --assume-unchanged AGENTS.md 2>/dev/null || true
    " 2>/dev/null || true
}

_create_wsl_worktree() {
    local wsl_path="$1" branch="$2" wsl_main="$3"
    echo "Creating WSL worktree: $wsl_path (branch: $branch)"
    # Fetch the specific branch with an explicit refspec so it works even if
    # the WSL clone has a narrow remote.origin.fetch (e.g. single-branch clone)
    if ! wsl -d Ubuntu -e bash -c "cd '$wsl_main' && git fetch origin '+refs/heads/$branch:refs/remotes/origin/$branch'"; then
        echo "Error: Failed to fetch branch '$branch' in WSL. Is $wsl_main a valid repo?"
        return 1
    fi
    if ! wsl -d Ubuntu -e bash -c "cd '$wsl_main' && git worktree add '$wsl_path' 'origin/$branch'"; then
        echo "Error: Failed to create worktree."
        echo "Debug: wsl -d Ubuntu -e bash -c \"cd '$wsl_main' && git worktree list\""
        return 1
    fi
}

# Codex in WSL - maps Windows worktree to WSL equivalent, creates if needed
# Usage: c [prompt]
c() {
    local win_dir
    win_dir=$(basename "$PWD")
    local wsl_path="$WSL_PROJECTS/$win_dir"

    # Check if we're in a quinlan worktree
    if [[ ! "$win_dir" == quinlan* ]]; then
        echo "Error: Not in a quinlan worktree (current: $win_dir)"
        return 1
    fi

    # Ensure WSL worktree exists and is synced
    _ensure_wsl_worktree "$win_dir"

    # Run Codex in WSL (blocking)
    echo "Starting Codex in WSL: $wsl_path"
    wsl -- bash -lc "source ~/.nvm/nvm.sh 2>/dev/null; cd $wsl_path && codex --dangerously-bypass-approvals-and-sandbox $*"
}

# Codex in WSL pane (non-blocking, opens new wezterm pane)
# Usage: cpane
cpane() {
    local win_dir
    win_dir=$(basename "$PWD")
    local wsl_path="$WSL_PROJECTS/$win_dir"

    # Check if we're in a quinlan worktree
    if [[ ! "$win_dir" == quinlan* ]]; then
        echo "Error: Not in a quinlan worktree (current: $win_dir)"
        return 1
    fi

    # Ensure WSL worktree exists
    _ensure_wsl_worktree "$win_dir"

    # Open WSL pane and launch Codex (start in home to avoid /mnt path)
    local pane
    pane=$(wezterm cli split-pane --right --percent 40 -- wsl.exe -d Ubuntu --cd "~")
    sleep 1  # WSL takes longer to start than bash
    wezterm cli send-text --pane-id "$pane" "cd $wsl_path && source ~/.nvm/nvm.sh && codex --dangerously-bypass-approvals-and-sandbox"$'\n'

    echo "Codex pane opened in WSL: $wsl_path"
}

# ---------------------------------------------------------------------------
# Cross-filesystem sync (Windows <-> WSL)
# ---------------------------------------------------------------------------

# Create WIP commit for syncing (run on Windows)
wip() {
    if [[ -z $(git status --porcelain) ]]; then
        echo "No changes to commit"
        return 1
    fi
    git add -A && git commit -m "WIP: sync"
    echo "WIP commit created. Run 'sync' in WSL, then 'unwip' here when done."
}

# Pull changes from Windows (run in WSL, or from Windows via this wrapper)
sync() {
    local win_dir
    win_dir=$(basename "$PWD")
    local wsl_path="$WSL_PROJECTS/$win_dir"
    wsl -d Ubuntu -- bash -c "cd $wsl_path && git pull windows $(git branch --show-current) --ff-only"
    echo "WSL synced with Windows"
}

# Undo WIP commit, keep changes staged (run on Windows after review)
unwip() {
    local msg
    msg=$(git log -1 --format=%s)
    if [[ "$msg" == "WIP: sync" ]]; then
        git reset --soft HEAD~1
        echo "WIP commit undone. Changes are staged."
    else
        echo "Last commit isn't a WIP commit: $msg"
        return 1
    fi
}

# Dev layout: 2x2 panes with Claude Code (top, bash) and Codex (bottom, WSL)
# Usage: dev [2] [directory|branch]
dev() {
    local panes=4
    local arg="${1:-}"

    # Check for pane count argument
    if [[ "$arg" == "2" ]]; then
        panes=2
        shift
        arg="${1:-}"
    fi

    local dir=""
    local branch=""
    local win_dir=""
    local wsl_path=""
    local tab_name=""
    local workspace="${WORKSPACE_ROOT:-/e/projects/main_workspace}"
    local main_repo="$workspace/quinlan"

    if [[ -z "$arg" ]]; then
        dir="$(pwd)"
    elif [[ -d "$arg" ]] || [[ "$arg" == /* ]] || [[ "$arg" == ./* ]] || [[ "$arg" == ../* ]]; then
        dir="$arg"
    elif [[ "$arg" == */* ]]; then
        branch="$arg"
    else
        echo "Error: '$arg' doesn't look like a path or branch."
        echo ""
        echo "Usage:"
        echo "  dev                     # Open 4-pane layout in current worktree"
        echo "  dev 2                   # Open 2-pane layout (1 Claude, 1 Codex)"
        echo "  dev feat/my-feature     # Create/open worktree for branch"
        echo "  dev 2 feat/my-feature   # 2-pane layout for branch"
        echo "  dev /path/to/worktree   # Open layout for existing path"
        echo ""
        echo "Branch prefixes: feat/ fix/ chore/ docs/ hotfix/ experiment/"
        return 1
    fi

    if [[ -n "$branch" ]]; then
        local suffix="${branch##*/}"
        win_dir="quinlan-$suffix"
        dir="$(_ensure_win_worktree "$branch")" || return 1
        dir="$(cd "$dir" && pwd)" || return 1
        wsl_path="$WSL_PROJECTS/$win_dir"
        _ensure_wsl_worktree "$win_dir" "$branch" "$main_repo" || return 1
    else
        if [[ ! -d "$dir" ]]; then
            echo "Error: Directory not found: $dir"
            return 1
        fi
        dir="$(cd "$dir" && pwd)"
        if ! git -C "$dir" rev-parse --is-inside-work-tree &>/dev/null; then
            echo "Error: Not a git worktree: $dir"
            return 1
        fi
        win_dir=$(basename "$dir")
        if [[ ! "$win_dir" == quinlan* ]]; then
            echo "Error: Not in a quinlan worktree (current: $win_dir)"
            return 1
        fi
        wsl_path="$WSL_PROJECTS/$win_dir"
        git -C "$dir" config core.autocrlf input
        branch=$(git -C "$dir" branch --show-current 2>/dev/null)
        if [[ -z "$branch" ]]; then
            echo "Error: Unable to determine branch for $dir"
            return 1
        fi
        main_repo=$(git -C "$dir" rev-parse --show-toplevel 2>/dev/null)
        _ensure_wsl_worktree "$win_dir" "$branch" "$main_repo" || return 1
    fi

    cd "$dir" || return 1
    tab_name="$win_dir"

    # Use current pane as left/top-left
    local left_pane="${WEZTERM_PANE:-$(wezterm cli list --format json | jq -r 'first(.[] | select(.is_active)) | .pane_id')}"

    if [[ "$panes" == "2" ]]; then
        # 2-pane layout: Claude Code (left) | Codex (right)
        local right_pane
        right_pane=$(wezterm cli split-pane --right --percent 50 --pane-id "$left_pane" -- wsl.exe -d Ubuntu --cd "~")

        # Launch Claude Code (bash ready quickly)
        sleep 0.3
        wezterm cli send-text --pane-id "$left_pane" $'cc\n'

        # Launch Codex (WSL takes longer)
        sleep 2
        wezterm cli send-text --no-paste --pane-id "$right_pane" -- "cd $wsl_path && source ~/.nvm/nvm.sh && codex --dangerously-bypass-approvals-and-sandbox
"

        echo "Dev layout '$tab_name' ready: Claude Code (left) | Codex (right)"
    else
        # 4-pane layout: 2x2 grid
        # Top row: split right for second Claude Code pane
        local top_right
        top_right=$(wezterm cli split-pane --right --percent 50 --pane-id "$left_pane" --cwd "$dir")

        # Bottom row: WSL panes for Codex (start in home to avoid /mnt path)
        local bottom_left
        bottom_left=$(wezterm cli split-pane --bottom --percent 50 --pane-id "$left_pane" -- wsl.exe -d Ubuntu --cd "~")
        local bottom_right
        bottom_right=$(wezterm cli split-pane --bottom --percent 50 --pane-id "$top_right" -- wsl.exe -d Ubuntu --cd "~")

        # Top: launch Claude Code (bash is ready quickly)
        sleep 0.3
        wezterm cli send-text --pane-id "$left_pane" $'cc\n'
        wezterm cli send-text --pane-id "$top_right" $'cc\n'

        # Bottom: WSL takes longer to start (2s for shell prompt to be ready)
        sleep 2
        wezterm cli send-text --no-paste --pane-id "$bottom_left" -- "cd $wsl_path && source ~/.nvm/nvm.sh && codex --dangerously-bypass-approvals-and-sandbox
"
        wezterm cli send-text --no-paste --pane-id "$bottom_right" -- "cd $wsl_path && source ~/.nvm/nvm.sh && codex --dangerously-bypass-approvals-and-sandbox
"

        echo "Dev layout '$tab_name' ready: 2x Claude Code (top) | 2x Codex (bottom)"
    fi
}

fi  # end WSL integration

# ---------------------------------------------------------------------------
# Project picker (fzf)
# ---------------------------------------------------------------------------

# Project picker: type 'p' to fuzzy-select a project in main_workspace
# Also ensures WSL worktree exists for quinlan projects (in background)
p() {
    local workspace="${WORKSPACE_ROOT:-/e/projects/main_workspace}"
    local selected
    selected=$(find "$workspace" -maxdepth 1 -mindepth 1 -type d 2>/dev/null | \
        sed "s|$workspace/||" | \
        fzf --height 40% --reverse --prompt="project> ")

    [[ -z "$selected" ]] && return

    cd "$workspace/$selected" || return

    # If it's a quinlan project and WSL is available, sync worktree in background
    if [[ "$selected" == quinlan* ]] && type _ensure_wsl_worktree &>/dev/null; then
        (_ensure_wsl_worktree "$selected" &>/dev/null &)
        disown 2>/dev/null
        echo "WSL worktree sync started in background"
    fi
}

# ---------------------------------------------------------------------------
# Azure CLI: No wrapper needed — Microsoft's /c/Program Files/.../wbin/az
# shell script works natively in Git Bash. A previous az() wrapper that called
# az.cmd broke path resolution due to spaces in "Program Files".
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------
# Local extensions (personal overrides, not managed by chezmoi)
# shellcheck source=/dev/null
# ---------------------------------------------------------------------------
[[ -f ~/.bashrc.local ]] && source ~/.bashrc.local
